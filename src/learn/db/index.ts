import { prayTruthy } from "@/components/pray"
import {
  IDBPDatabase,
  IDBPObjectStore,
  IDBPTransaction,
  openDB,
  StoreNames,
  unwrap,
} from "idb"
import { Id, type IdZero } from "../lib/id"
import type {
  AnyCard,
  Conf,
  Core,
  Deck,
  Grave,
  Model,
  Note,
  Prefs,
  Review,
} from "../lib/types"
import type { Cloneable } from "../message"
import { Tx } from "../script"
import "./lastEditedHooks"
import type { Reason } from "./reason"
import { createUndoable, type UndoFunction } from "./undoHistoryHooks"
import { upgrade, VERSION } from "./upgrade"

/** Like the schema type in idb, but uses `Cloneable` to ensure type safety. */
export interface RequiredSchema {
  [s: string]: StoreTy
}

/** An individual store. */
export type StoreTy = {
  key: IDBValidKey
  mk: [IDBValidKey?]
  value: Cloneable
  indexes?: { [s: string]: IDBValidKey }
}

/** An object store which has inline or autogenerated keys. */
type NoMK = [key?: undefined]

/** An object store which requires an explicit key of ID_ZERO to be set. */
type MK0 = [key: IdZero]

/** The types for the learn database. */
export interface Ty extends RequiredSchema {
  cards: { key: Id; mk: NoMK; value: AnyCard; indexes: { nid: Id; did: Id } }
  graves: { key: number; mk: NoMK; value: Grave; indexes: {} }
  notes: { key: Id; mk: NoMK; value: Note; indexes: { mid: Id } }
  rev_log: { key: Id; mk: NoMK; value: Review; indexes: { cid: Id } }
  core: { key: IdZero; mk: MK0; value: Core; indexes: {} }
  models: { key: Id; mk: NoMK; value: Model; indexes: {} }
  decks: { key: Id; mk: NoMK; value: Deck; indexes: { cfid: Id; name: string } }
  confs: { key: Id; mk: NoMK; value: Conf; indexes: {} }
  prefs: { key: IdZero; mk: MK0; value: Prefs; indexes: {} }
}

export async function open(name: string, now: number): Promise<DB> {
  return new DB(await openDB(name, VERSION, { upgrade: upgrade(now) }))
}

export class DB {
  private last?: {
    reason: Reason
    undo: UndoFunction
    redo: boolean
  }

  private raw: IDBDatabase

  constructor(private db: IDBPDatabase<Ty>) {
    this.raw = unwrap(db as IDBPDatabase)
  }

  undo() {
    const { last } = this
    if (!last) return
    const redo = last.undo()
    this.last = {
      reason: last.reason,
      redo: !last.redo,
      undo: async () => {
        const r = await redo
        if (typeof r == "function") {
          return r()
        } else {
          return false
        }
      },
    }
    return { last, done: redo.then(() => {}) }
  }

  read<Name extends StoreNames<Ty>>(
    storeNames: Name,
    options?: IDBTransactionOptions,
  ): IDBPTransaction<Ty, [Name], "readonly">

  read<Names extends ArrayLike<StoreNames<Ty>>>(
    storeNames: Names,
    options?: IDBTransactionOptions,
  ): IDBPTransaction<Ty, Names, "readonly">

  read<Names extends StoreNames<Ty> | ArrayLike<StoreNames<Ty>>>(
    storeNames: Names,
    options?: IDBTransactionOptions,
  ): any {
    return this.db.transaction(storeNames as any, "readonly", options)
  }

  readwrite<Name extends StoreNames<Ty>>(
    storeNames: Name,
    reason: Reason,
    options?: IDBTransactionOptions,
  ): IDBPTransaction<Ty, [Name], "readwrite">

  readwrite<Names extends ArrayLike<StoreNames<Ty>>>(
    storeNames: Names,
    reason: Reason,
    options?: IDBTransactionOptions,
  ): IDBPTransaction<Ty, Names, "readwrite">

  readwrite(
    storeNames: string | string[],
    reason: Reason,
    options?: IDBTransactionOptions,
  ) {
    const tx = this.db.transaction(storeNames as any, "readwrite", options)
    const undo = createUndoable(tx)
    this.last = {
      reason,
      redo: false,
      undo,
    }
    return tx
  }

  tx<T extends StoreNames<Ty>>(
    stores: T | T[],
    mode?: "readonly",
    reason?: undefined,
  ): Tx

  tx<T extends StoreNames<Ty>>(
    stores: T | T[],
    mode: "readwrite",
    reason: Reason,
  ): Tx

  tx<T extends StoreNames<Ty>>(
    stores: T | T[],
    mode?: IDBTransactionMode,
    reason?: Reason,
  ) {
    if (mode == "readwrite") {
      prayTruthy(reason, "Must provide a reason for readwrite operations.")
      const tx = this.db.transaction(stores as any, "readwrite")
      const undo = createUndoable(tx)
      this.last = {
        reason,
        redo: false,
        undo,
      }
      return new Tx(unwrap(tx))
    } else {
      const tx = this.raw.transaction(stores, mode)
      return new Tx(tx)
    }
  }
}

// a lot of really stupid typescript stuff because typescript sucks

export type TxWithExtends = Omit<
  IDBTransaction,
  "db" | "objectStore" | "objectStoreNames"
>

export interface TxWith<
  T extends StoreNames<Ty>,
  Mode extends IDBTransactionMode = "readonly",
> extends TxWithExtends {
  /**
   * The transaction's mode.
   */
  readonly mode: Mode
  /**
   * Promise for the completion of this transaction.
   */
  readonly done: Promise<void>
  /**
   * Returns an IDBObjectStore in the transaction's scope.
   */
  objectStore<StoreName extends T>(
    name: StoreName,
  ): ObjectStoreWith<Ty, T[], StoreName, Mode>
}

export type ObjectStoreExtends<
  DBTypes extends RequiredSchema | unknown = unknown,
  TxStores extends ArrayLike<StoreNames<DBTypes>> = ArrayLike<
    StoreNames<DBTypes>
  >,
  StoreName extends StoreNames<DBTypes> = StoreNames<DBTypes>,
  Mode extends IDBTransactionMode = "readonly",
> = Omit<
  IDBPObjectStore<DBTypes, TxStores, StoreName, Mode>,
  // FIXME: type these properly
  | "transaction"
  | "indexNames"
  | "index"
  | typeof Symbol.asyncIterator
  | "openCursor"
  | "openKeyCursor"
  | "iterate"
>

export interface ObjectStoreWith<
  DBTypes extends RequiredSchema | unknown = unknown,
  TxStores extends ArrayLike<StoreNames<DBTypes>> = ArrayLike<
    StoreNames<DBTypes>
  >,
  StoreName extends StoreNames<DBTypes> = StoreNames<DBTypes>,
  Mode extends IDBTransactionMode = "readonly",
> extends ObjectStoreExtends<DBTypes, TxStores, StoreName, Mode> {}
